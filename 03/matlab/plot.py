#!/usr/bin/python3
import matplotlib.pyplot as plt
import numpy as np
from numpy import log

ls_obja = np.loadtxt('ls_obja.dat', delimiter=',')
ls_objb = np.loadtxt('ls_objb.dat', delimiter=',')
ls_banana = np.loadtxt('ls_banana.dat', delimiter=',')
back_obja = np.loadtxt('back_obja.dat', delimiter=',')
back_objb = np.loadtxt('back_objb.dat', delimiter=',')
back_banana = np.loadtxt('back_banana.dat', delimiter=',')
# scatter plot of iterations
plt.figure(1)
plt.scatter(ls_obja[:,0], log(ls_obja[:,2]), s=3, label='obja')
plt.scatter(ls_objb[:,0], log(ls_objb[:,2]), s=3, label='objb')
plt.scatter(ls_banana[:,0], log(ls_banana[:,2]), s=3, label='rosenbrock')
# plt.title('Number of iterations needed in steepest descent \nwith exact line search under eta')
# plt.ylim((0,12000))
plt.xlabel('eta')
plt.ylabel('ln(numIter)')
ax = plt.subplot(111)
box = ax.get_position()
ax.set_position([box.x0, box.y0, box.width * 0.8, box.height])
ax.legend(loc='center left', bbox_to_anchor=(1, 0.5))
plt.savefig('ls_iter.png', dpi=1000)

# scatter plot of function evaluations
plt.figure(2)
plt.scatter(ls_obja[:,0], log(ls_obja[:,3]), s=3, label='obja')
plt.scatter(ls_objb[:,0], log(ls_objb[:,3]), s=3, label='objb')
plt.scatter(ls_banana[:,0], log(ls_banana[:,3]), s=3, label='rosenbrock')
plt.xlabel('eta')
plt.ylabel('ln(numf)')
ax = plt.subplot(111)
box = ax.get_position()
ax.set_position([box.x0, box.y0, box.width * 0.8, box.height])
ax.legend(loc='center left', bbox_to_anchor=(1, 0.5))
plt.savefig('ls_feval.png', dpi=1000)
# scatter plot of gradient evaluations
plt.figure(3)
plt.scatter(ls_obja[:,0], log(ls_obja[:,4]), s=3, label='obja')
plt.scatter(ls_objb[:,0], log(ls_objb[:,4]), s=3, label='objb')
plt.scatter(ls_banana[:,0], log(ls_banana[:,4]), s=3, label='rosenbrock')
plt.xlabel('eta')
plt.ylabel('ln(numg)')
ax = plt.subplot(111)
box = ax.get_position()
ax.set_position([box.x0, box.y0, box.width * 0.8, box.height])
ax.legend(loc='center left', bbox_to_anchor=(1, 0.5))
plt.savefig('ls_geval.png', dpi=1000)

# scatter plot of iterations
plt.figure(4)
plt.scatter(back_obja[:,0], np.log(back_obja[:,2]), s=3, label='obja')
plt.scatter(back_objb[:,0], np.log(back_objb[:,2]), s=3, label='objb')
plt.scatter(back_banana[:,0], np.log(back_banana[:,2]), s=3, label='rosenbrock')
# plt.title('Number of iterations needed in steepest descent \nwith exact line search under eta')
# plt.ylim((0,12000))
plt.xlabel('eta')
plt.ylabel('ln(numIter)')
ax = plt.subplot(111)
box = ax.get_position()
ax.set_position([box.x0, box.y0, box.width * 0.8, box.height])
ax.legend(loc='center left', bbox_to_anchor=(1, 0.5))
plt.savefig('back_iter.png', dpi=1000)
# scatter plot of function evaluations
plt.figure(5)
plt.scatter(back_obja[:,0],np.log(back_obja[:,3]), s=3, label='obja')
plt.scatter(back_objb[:,0],np.log(back_objb[:,3]), s=3, label='objb')
plt.scatter(back_banana[:,0],np.log(back_banana[:,3]), s=3, label='rosenbrock')
plt.xlabel('eta')
plt.ylabel('ln(numf)')
ax = plt.subplot(111)
box = ax.get_position()
ax.set_position([box.x0, box.y0, box.width * 0.8, box.height])
ax.legend(loc='center left', bbox_to_anchor=(1, 0.5))
plt.savefig('back_feval.png', dpi=1000)
# scatter plot of gradient evaluations
plt.figure(6)
plt.scatter(back_obja[:,0],np.log(back_obja[:,4]), s=3, label='obja')
plt.scatter(back_objb[:,0],np.log(back_objb[:,4]), s=3, label='objb')
plt.scatter(back_banana[:,0],np.log(back_banana[:,4]), s=3, label='rosenbrock')
plt.xlabel('eta')
plt.ylabel('ln(numg)')
ax = plt.subplot(111)
box = ax.get_position()
ax.set_position([box.x0, box.y0, box.width * 0.8, box.height])
ax.legend(loc='center left', bbox_to_anchor=(1, 0.5))
plt.savefig('back_geval.png', dpi=1000)

